#!/usr/bin/env bash

# `git-cliff --unreleased --prepend CHANGELOG.md` does not account for a pre-existing
# Unreleased section and will insert anew no matter what.
# This script is a workaround that replaces an existing Unreleased section with a new
# one generated by git cliff, avoiding duplicated Unreleased headings.
# This is useful for CI/CD pipelines that need to update the changelog automatically.
# In addition, it provides an option to automatically stage and commit the changes.

set -euo pipefail

SCRIPT_NAME=$(basename "$0")
COMMIT=""
SHOULD_COMMIT=false
CHANGELOG="CHANGELOG.md"
CLIFF_ARGS=""

# Initialize arrays early to avoid unbound variable errors with set -u
CLIFF_ARGS_ARRAY=()
COMMIT_ARGS_ARRAY=()

# Initialize temporary file variables for cleanup
TEMP_FILE=""
CLIFF_OUTPUT=""
HEAD_CHANGELOG=""
EXPECTED_OUTPUT=""
STAGED_CONTENT=""

usage() {
  cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

Update the Unreleased section of CHANGELOG.md using git cliff.

This script runs 'git cliff --unreleased' to generate fresh changelog content,
then replaces the existing ## [Unreleased] section in CHANGELOG.md with the
newly generated content.

The '<!-- generated by git-cliff -->' comment is automatically excluded.

Options:
  -c, --commit        Stage and commit CHANGELOG.md after updating.
                      Use -- to separate script options from git commit options.
                      Example: --commit -- -m "Custom message"
  -l, --changelog     path to changelog file (default: CHANGELOG.md)
  -C, --cliff-args    additional arguments to pass with 'git-cliff --unreleased'.
                      Use -- to separate script options from git-cliff options.
                      Example: --cliff-args -- --config custom-cliff.toml
  -h, --help          Show this help message and exit.

Examples:
  $SCRIPT_NAME                                                          # Update CHANGELOG.md only
  $SCRIPT_NAME --commit                                                 # Update, stage, and commit CHANGELOG.md (with defaults)
  $SCRIPT_NAME --commit -- -m "Custom message"                          # Commit with custom message
  $SCRIPT_NAME -l HISTORY.md                                            # Update HISTORY.md instead
  $SCRIPT_NAME --cliff-args -- --config custom-cliff.toml               # Pass args to git-cliff
  $SCRIPT_NAME --cliff-args -- --config file.toml --commit -- -m "msg"  # Both with -- separators
  $SCRIPT_NAME --help                                                   # Show this help message

Requirements:
  - git cliff must be installed and available in PATH
  - Must be run from a git repository with a cliff.toml configuration
EOF
  exit "${1:-0}"
}

# Parse arguments
# Helper function to check if an argument is a recognized option
is_option() {
  case "$1" in
    -c | --commit | -l | --changelog | -C | --cliff-args | -h | --help | --)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -c | --commit)
      SHOULD_COMMIT=true
      # Only consume next arg if it's not a recognized option or --
      # This allows --commit to work with other options in any order
      if [[ $# -gt 1 ]] && [[ -n "${2:-}" ]]; then
        case "$2" in
          --)
            # -- separator: collect args until next recognized option
            shift 2
            COMMIT_ARGS_ARRAY=()
            while [[ $# -gt 0 ]]; do
              if is_option "$1"; then
                # Hit a recognized option, stop collecting and continue parsing
                break
              fi
              COMMIT_ARGS_ARRAY+=("$1")
              shift
            done
            # Continue parsing with the option we hit (if any)
            continue
            ;;
          -c | --commit | -l | --changelog | -C | --cliff-args | -h | --help)
            # Next arg is an option, don't consume it
            COMMIT=""
            shift
            ;;
          *)
            # Next arg is not an option - capture it as commit args (backward compatibility)
            # (even if it starts with -, as commit args like -m are valid)
            COMMIT="$2"
            shift 2
            ;;
        esac
      else
        # No arg or empty string: use defaults
        COMMIT=""
        shift
      fi
      ;;
    -l | --changelog)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --changelog requires a file path" >&2
        usage 1
      fi
      CHANGELOG="$2"
      shift 2
      ;;
    -C | --cliff-args)
      # Check if next arg is -- separator
      if [[ $# -gt 1 ]] && [[ "${2:-}" == "--" ]]; then
        # -- separator: collect args until next recognized option
        shift 2
        CLIFF_ARGS_ARRAY=()
        while [[ $# -gt 0 ]]; do
          if is_option "$1"; then
            # Hit a recognized option, stop collecting and continue parsing
            break
          fi
          CLIFF_ARGS_ARRAY+=("$1")
          shift
        done
        # Continue parsing with the option we hit (if any)
        continue
      elif [[ -z "${2:-}" ]]; then
        echo "Error: --cliff-args requires arguments" >&2
        usage 1
      else
        # Capture as quoted string (backward compatibility)
        CLIFF_ARGS="$2"
        shift 2
      fi
      ;;
    -h | --help)
      usage 0
      ;;
    *)
      echo "Error: Unknown option: $1" >&2
      usage 1
      ;;
  esac
done

# Check we're in a git repository
if [ ! -d .git ]; then
  echo "Error: Must be run from the root of a git repository." >&2
  exit 1
fi

# Check git cliff is installed
if ! command -v git-cliff > /dev/null 2>&1 && ! command -v git cliff > /dev/null 2>&1; then
  echo "Error: git cliff is not installed or not available in PATH" >&2
  echo "Install it with: cargo install git-cliff" >&2
  exit 1
fi

# Check if changelog file exists
if [[ ! -f "$CHANGELOG" ]]; then
  echo "Error: $CHANGELOG does not exist" >&2
  exit 1
fi

COMMIT_MSG="docs(${CHANGELOG}): autoupdate Unreleased section"

# Check if the last commit was an auto-update (avoid infinite loop)
LAST_COMMIT_MSG=$(git log -1 --pretty=%s 2> /dev/null || true)
LAST_COMMIT_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD 2> /dev/null || true)
if [[ $LAST_COMMIT_MSG == "$COMMIT_MSG" && $LAST_COMMIT_FILES == "$CHANGELOG" ]]; then
  echo "Skipping: Last commit was already a CHANGELOG auto-update."
  echo "No new commits to include."
  exit 0
fi

# Parse shell-quoted arguments into null-delimited output
# Safely handles single quotes, double quotes, and escaping without using eval
parse_shell_args() {
  local input="$1"
  local arg=""
  local in_single_quote=false
  local in_double_quote=false
  local escaped=false
  local i=0
  local char

  while [[ $i -lt ${#input} ]]; do
    char="${input:$i:1}"

    if $escaped; then
      # Previous char was backslash - add current char literally
      arg+="$char"
      escaped=false
    elif [[ $char == $'\\' ]] && ! $in_single_quote; then
      # Backslash outside single quotes - escape next char
      escaped=true
    elif [[ $char == "'" ]] && ! $in_double_quote; then
      # Single quote (not inside double quotes)
      if $in_single_quote; then
        in_single_quote=false
      else
        in_single_quote=true
      fi
    elif [[ $char == '"' ]] && ! $in_single_quote; then
      # Double quote (not inside single quotes)
      if $in_double_quote; then
        in_double_quote=false
      else
        in_double_quote=true
      fi
    elif [[ $char =~ [[:space:]] ]] && ! $in_single_quote && ! $in_double_quote; then
      # Whitespace outside quotes - end current arg
      if [[ -n $arg ]]; then
        printf '%s\0' "$arg"
        arg=""
      fi
    else
      # Regular character - add to current arg
      arg+="$char"
    fi

    i=$((i + 1))
  done

  # Output final arg if not empty
  if [[ -n $arg ]]; then
    printf '%s\0' "$arg"
  fi
}

# Convert string arguments to arrays for safe expansion
# Arrays are initialized at the top, but may have been populated by -- separator parsing
# If not populated and we have quoted string args, parse them now
if [[ -n "$CLIFF_ARGS" ]] && [[ ${#CLIFF_ARGS_ARRAY[@]} -eq 0 ]]; then
  # Parse shell-quoted arguments safely without eval (backward compatibility)
  # This handles quoted strings like "--foo 'bar baz'" without code execution
  readarray -d '' CLIFF_ARGS_ARRAY < <(parse_shell_args "$CLIFF_ARGS")
fi
if [[ -n "$COMMIT" ]] && [[ ${#COMMIT_ARGS_ARRAY[@]} -eq 0 ]]; then
  # Parse shell-quoted arguments safely without eval (backward compatibility)
  # This handles quoted strings like "-m 'Custom message'" without code execution
  readarray -d '' COMMIT_ARGS_ARRAY < <(parse_shell_args "$COMMIT")
fi

STASHED=false
STASH_REF=""
STASH_MSG="update-unreleased: auto-stash ${CHANGELOG}"
STAGED_DIFFS_DIR=""

# Helper to re-stage files, preserving partial staging
restage_other_files() {
  if [[ -z "$OTHER_STAGED_FILES" ]]; then
    return
  fi
  echo "Re-staging other files..."
  while IFS= read -r file; do
    local patch_file="${STAGED_DIFFS_DIR}/${file}.patch"
    # If we have a saved staged diff, apply it to preserve partial staging
    if [[ -n "$STAGED_DIFFS_DIR" ]] && [[ -f "$patch_file" ]] && [[ -s "$patch_file" ]]; then
      # Apply the saved staged diff to restore exact staging state
      if ! git apply --cached --allow-empty "$patch_file" 2> /dev/null; then
        # Fallback: if patch doesn't apply, try to be smarter about re-staging.
        echo "Warning: Could not restore partial staging for '$file', attempting to stage based on patch type." >&2
        if grep -q '^deleted file mode' "$patch_file"; then
          # The patch was for a deletion. `git apply` likely failed because the file was re-created.
          # Respect the original intent and stage the deletion.
          git rm --cached --ignore-unmatch -- "$file"
        else
          # For modifications or new files, staging the whole file is a reasonable fallback.
          git add -- "$file"
        fi
      fi
    else
      # No saved diff or empty diff (shouldn't happen, but fallback to full staging)
      # This handles both existing files and staged deletions.
      git add -- "$file"
    fi
  done <<< "$OTHER_STAGED_FILES"
  # Clean up temp directory after restaging
  if [[ -n "$STAGED_DIFFS_DIR" ]] && [[ -d "$STAGED_DIFFS_DIR" ]]; then
    rm -rf "$STAGED_DIFFS_DIR"
    STAGED_DIFFS_DIR=""
  fi
}

# Commit CHANGELOG with appropriate message handling
commit_changelog() {
  # Check if user provided -m or --message in commit args
  local has_message=false
  for arg in "${COMMIT_ARGS_ARRAY[@]}"; do
    if [[ "$arg" == "-m" ]] || [[ "$arg" == "--message" ]]; then
      has_message=true
      break
    fi
  done

  # Build commit command
  local commit_cmd=(git commit)
  if [[ $has_message == false ]]; then
    commit_cmd+=(-m "$COMMIT_MSG")
  fi
  commit_cmd+=("${COMMIT_ARGS_ARRAY[@]}")
  commit_cmd+=(-- "$CHANGELOG")

  # Execute command
  "${commit_cmd[@]}"
}

# Cleanup function to restore state on error
cleanup() {
  local exit_code=$?
  rm -f "$TEMP_FILE" "$CLIFF_OUTPUT" "$HEAD_CHANGELOG" "$EXPECTED_OUTPUT" "$STAGED_CONTENT"
  if [[ $STASHED == true ]] && [[ -n "$STASH_REF" ]]; then
    # Check if stash still exists before trying to pop
    if git stash list | grep -q "^${STASH_REF}"; then
      echo "Restoring stashed changes to ${CHANGELOG}..." >&2
      git stash pop --quiet "$STASH_REF" 2> /dev/null
    fi
  fi
  restage_other_files
  # Clean up temp directory if it still exists
  if [[ -n "$STAGED_DIFFS_DIR" ]] && [[ -d "$STAGED_DIFFS_DIR" ]]; then
    rm -rf "$STAGED_DIFFS_DIR"
  fi
  exit $exit_code
}
trap cleanup EXIT

# Track if CHANGELOG.md is already staged with correct content
CHANGELOG_ALREADY_STAGED=false
# Track other staged files we temporarily unstage
OTHER_STAGED_FILES=""

# If committing, check for conflicting staged changes
if [[ "$SHOULD_COMMIT" == true ]]; then
  # Check if CHANGELOG.md has staged changes
  if git diff --cached --name-only | grep -q "^${CHANGELOG}$"; then
    # CHANGELOG.md is staged - check if it matches what git cliff would generate
    # We'll verify this after generating the expected content
    CHANGELOG_ALREADY_STAGED=true
  fi

  # Temporarily unstage other files so they don't get included in our commit
  OTHER_STAGED_FILES=$(git diff --cached --name-only | grep -v "^${CHANGELOG}$" || true)
  if [[ -n $OTHER_STAGED_FILES ]]; then
    echo "Temporarily unstaging other files..."
    # Create temp directory to store staged diffs for preserving partial staging
    STAGED_DIFFS_DIR=$(mktemp -d)
    while IFS= read -r file; do
      # Create parent directory for the patch file
      mkdir -p "$(dirname "${STAGED_DIFFS_DIR}/${file}")"
      # Save the staged diff before unstaging to preserve partial hunks
      # This works for both partially staged files and new files
      git diff --cached -- "$file" > "${STAGED_DIFFS_DIR}/${file}.patch" 2> /dev/null || true
      git restore --staged -- "$file"
    done <<< "$OTHER_STAGED_FILES"
  fi
fi

# Stash uncommitted changes to CHANGELOG.md if any
if ! git diff --quiet "$CHANGELOG" 2> /dev/null; then
  echo "Stashing uncommitted changes to ${CHANGELOG}..."
  git stash push -m "$STASH_MSG" -- "$CHANGELOG"
  STASHED=true
  # Track the stash reference (most recent stash matching our message)
  STASH_REF=$(git stash list | grep -m1 -F "$STASH_MSG" | cut -d: -f1 || true)
fi

TEMP_FILE=$(mktemp)
CLIFF_OUTPUT=$(mktemp)

# Generate unreleased changes with git cliff
git cliff --unreleased "${CLIFF_ARGS_ARRAY[@]}" > "$CLIFF_OUTPUT"

# Extract the Unreleased section from git cliff output:
# - Start from "## [Unreleased]"
# - End before the next "## [" or "<!-- generated by git-cliff -->"
# - Exclude the git-cliff generated comment
awk '
  /^## \[Unreleased\]/ { in_unreleased = 1 }
  in_unreleased && /^<!-- generated by git-cliff -->/ { exit }
  in_unreleased && /^## \[/ && !/^## \[Unreleased\]/ { exit }
  in_unreleased { print }
' "$CLIFF_OUTPUT" > "$TEMP_FILE"

# Check if we got valid content
if [ ! -s "$TEMP_FILE" ]; then
  echo "Error: No Unreleased section found in git cliff output" >&2
  rm -f "$TEMP_FILE" "$CLIFF_OUTPUT"
  exit 1
fi

# Remove trailing whitespace and ensure the extracted section ends with exactly one newline
# Use a cross-platform approach: read file, remove trailing whitespace, ensure single newline
if command -v perl > /dev/null 2>&1; then
  # Perl is more reliable across platforms
  # This removes all trailing whitespace (spaces, tabs, newlines) and adds exactly one newline
  perl -i -0777 -pe 's/\s*$/\n/' "$TEMP_FILE" 2> /dev/null || true
else
  # Fallback: use shell parameter expansion to trim trailing whitespace
  # and add a single newline. This is more portable and correct than sed.
  content=$(< "$TEMP_FILE")
  printf "%s\n" "${content%"${content##*[![:space:]]}"}" > "$TEMP_FILE"
fi

# Now replace the Unreleased section in CHANGELOG.md
# We need to:
# 1. Keep everything before "## [Unreleased]"
# 2. Insert the new Unreleased content
# 3. Keep everything from the next "## [" section onwards
# 4. If no Unreleased section exists, add it after header lines but before first version

# Define the awk script for replacing Unreleased section (reused in two places)
REPLACE_UNRELEASED_AWK_SCRIPT='
  function print_new_content() {
    while ((getline line < new_content) > 0) {
      print line
    }
    close(new_content)
    printed_new = 1
  }

  BEGIN { in_unreleased = 0; printed_new = 0 }

  # When we hit the Unreleased header, start skipping
  /^## \[Unreleased\]/ {
    in_unreleased = 1
    print_new_content()
    next
  }

  # When we hit the next version section, stop skipping
  in_unreleased && /^## \[/ && !/^## \[Unreleased\]/ {
    in_unreleased = 0
    # Ensure blank line before next section
    print ""
    print
    next
  }

  # Skip lines while in the old Unreleased section
  in_unreleased { next }

  # If we hit the first version section and Unreleased has not been printed yet, insert it
  !printed_new && /^## \[/ && !/^## \[Unreleased\]/ {
    # Insert Unreleased section before this version
    print_new_content()
    # Ensure blank line before version section
    print ""
    print
    next
  }

  # Print all other lines
  { print }

  # If we reach the end and Unreleased has not been printed, add it
  END {
    if (!printed_new) {
      # Add blank line if file does not end with one
      if (NR > 0) print ""
      print_new_content()
    }
  }
'

awk -v new_content="$TEMP_FILE" "$REPLACE_UNRELEASED_AWK_SCRIPT" "$CHANGELOG" > "${CHANGELOG}.new"

# If CHANGELOG.md is already staged, verify it matches what we'd generate
if [[ $CHANGELOG_ALREADY_STAGED == true ]]; then
  # Generate expected output from HEAD (not working tree which may be corrupted)
  HEAD_CHANGELOG=$(mktemp)
  EXPECTED_OUTPUT=$(mktemp)
  git show "HEAD:${CHANGELOG}" > "$HEAD_CHANGELOG"

  # Apply git cliff's Unreleased section to HEAD version
  awk -v new_content="$TEMP_FILE" "$REPLACE_UNRELEASED_AWK_SCRIPT" "$HEAD_CHANGELOG" > "$EXPECTED_OUTPUT"

  # Get the staged version and compare
  STAGED_CONTENT=$(mktemp)
  git show ":${CHANGELOG}" > "$STAGED_CONTENT"

  if diff -q "$STAGED_CONTENT" "$EXPECTED_OUTPUT" > /dev/null 2>&1; then
    # Staged content matches - no need to update, just commit
    echo "Staged ${CHANGELOG} already matches git cliff output."
    rm -f "$STAGED_CONTENT" "$EXPECTED_OUTPUT" "$HEAD_CHANGELOG" "${CHANGELOG}.new" "$TEMP_FILE" "$CLIFF_OUTPUT"

    # Commit the already-staged changes
    commit_changelog
    echo "Committed ${CHANGELOG}."
    exit 0
  else
    # Staged content differs from what we'd generate
    echo "Error: ${CHANGELOG} has staged changes that differ from git cliff output." >&2
    echo "Unstage with: git restore --staged ${CHANGELOG}" >&2
    rm -f "$STAGED_CONTENT" "$EXPECTED_OUTPUT" "$HEAD_CHANGELOG" "${CHANGELOG}.new" "$TEMP_FILE" "$CLIFF_OUTPUT"
    exit 1
  fi
fi

# Replace the original file
mv "${CHANGELOG}.new" "$CHANGELOG"

# Cleanup
rm -f "$TEMP_FILE" "$CLIFF_OUTPUT"

# Check if git cliff produced any changes (comparing to HEAD)
# Only check if file exists in HEAD - untracked files should always be updated
if git cat-file -e "HEAD:${CHANGELOG}" 2> /dev/null && git diff --quiet HEAD -- "$CHANGELOG" 2> /dev/null; then
  # File exists in HEAD and matches - already up-to-date
  if [[ $STASHED == true ]] && [[ -n "$STASH_REF" ]]; then
    # Restore user's original uncommitted changes
    git stash pop --quiet "$STASH_REF" 2> /dev/null
    STASHED=false
    STASH_REF=""
    echo "Unreleased section is already up-to-date (your changes preserved)."
  else
    echo "Unreleased section is already up-to-date."
  fi
  # Re-stage other files before exiting
  restage_other_files
  trap - EXIT
  exit 0
fi

# Git cliff produced changes. Handle stashed user edits if any.
HAS_USER_EDITS=false
if [[ $STASHED == true ]] && [[ -n "$STASH_REF" ]]; then
  # Check if stashed content matches current working tree (user already had same changes)
  # Use the tracked stash reference if available, otherwise fall back to stash@{0}
  STASH_TO_CHECK="${STASH_REF:-stash@{0}}"
  if diff -q <(git show "${STASH_TO_CHECK}:${CHANGELOG}" 2> /dev/null) "$CHANGELOG" > /dev/null 2>&1; then
    # Stashed changes are identical to git cliff output - just drop the stash
    git stash drop --quiet "$STASH_REF" 2> /dev/null || git stash drop --quiet
    STASHED=false
    STASH_REF=""
    echo "Your uncommitted changes match the git cliff output."
  else
    # User has different edits that need to be applied after committing
    HAS_USER_EDITS=true
  fi
fi

# Re-stage other files and disable cleanup trap - we're handling things manually from here
restage_other_files
trap - EXIT

echo "Successfully updated Unreleased section in $CHANGELOG"

# Stage and commit if requested
if [[ "$SHOULD_COMMIT" == true ]]; then
  git add "$CHANGELOG"
  commit_changelog
fi

# Now apply user's stashed edits on top (after the commit)
if [[ $HAS_USER_EDITS == true ]] && [[ -n "$STASH_REF" ]]; then
  # Use the tracked stash reference if available
  if git stash apply --quiet "$STASH_REF" 2> /dev/null; then
    # User's changes applied cleanly on top
    git stash drop --quiet "$STASH_REF" 2> /dev/null || git stash drop --quiet
    STASHED=false
    STASH_REF=""
    # Check if stash actually added any changes beyond the update
    if git diff --quiet "$CHANGELOG" 2> /dev/null; then
      echo "Your uncommitted changes were already included in the update."
    else
      echo "Applied your uncommitted changes on top of the update."
    fi
  else
    # Conflict - undo the commit if we made one, restore original state
    echo "Error: Your uncommitted changes conflict with the git cliff update." >&2
    # First, abort the failed stash apply (clear merge state)
    git reset --merge
    if [[ "$SHOULD_COMMIT" == true ]]; then
      echo "Reverting the commit..." >&2
      git reset --soft HEAD~1
      git restore --staged "$CHANGELOG"
    fi
    echo "Restoring your original changes..." >&2
    # Reset file to HEAD (discard the git cliff update)
    git checkout HEAD -- "$CHANGELOG"
    # Restore user's original uncommitted changes
    git stash pop --quiet "$STASH_REF" 2> /dev/null
    STASHED=false
    STASH_REF=""
    restage_other_files
    exit 1
  fi
fi
