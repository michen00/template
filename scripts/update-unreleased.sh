#!/usr/bin/env bash

set -euo pipefail

SCRIPT_NAME=$(basename "$0")
COMMIT=false
COMMIT_MSG="docs(CHANGELOG.md): autoupdate Unreleased section"

usage() {
  cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

Update the Unreleased section of CHANGELOG.md using git cliff.

This script runs 'git cliff --unreleased' to generate fresh changelog content,
then replaces the existing ## [Unreleased] section in CHANGELOG.md with the
newly generated content.

The '<!-- generated by git-cliff -->' comment is automatically excluded.

Options:
  -c, --commit  Stage and commit CHANGELOG.md after updating.
  -h, --help    Show this help message and exit.

Examples:
  $SCRIPT_NAME              # Update CHANGELOG.md only
  $SCRIPT_NAME --commit     # Update, stage, and commit CHANGELOG.md
  $SCRIPT_NAME --help       # Show this help message

Requirements:
  - git cliff must be installed and available in PATH
  - Must be run from a git repository with a cliff.toml configuration
  - CHANGELOG.md must exist with an existing ## [Unreleased] section
EOF
  exit "${1:-0}"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -c | --commit)
      COMMIT=true
      shift
      ;;
    -h | --help)
      usage 0
      ;;
    *)
      echo "Error: Unknown option: $1" >&2
      usage 1
      ;;
  esac
done

CHANGELOG="CHANGELOG.md"
STASHED=false
STASH_MSG="update-unreleased: auto-stash ${CHANGELOG}"

# Check we're in a git repository
if [ ! -d .git ]; then
  echo "Error: Must be run from the root of a git repository." >&2
  exit 1
fi

# Helper to re-stage files, skipping any that no longer exist
restage_other_files() {
  if [[ -z $OTHER_STAGED_FILES ]]; then
    return
  fi
  echo "Re-staging other files..."
  while IFS= read -r file; do
    if [[ -e $file ]]; then
      git add -- "$file"
    else
      echo "Warning: '$file' no longer exists (was it a new file?)" >&2
    fi
  done <<< "$OTHER_STAGED_FILES"
}

# Cleanup function to restore state on error
cleanup() {
  local exit_code=$?
  if [[ $STASHED == true ]] && git stash list | head -1 | grep -qF "$STASH_MSG"; then
    echo "Restoring stashed changes to ${CHANGELOG}..." >&2
    git stash pop --quiet
  fi
  restage_other_files
  exit $exit_code
}
trap cleanup EXIT

# Track if CHANGELOG.md is already staged with correct content
CHANGELOG_ALREADY_STAGED=false
# Track other staged files we temporarily unstage
OTHER_STAGED_FILES=""

# If committing, check for conflicting staged changes
if [[ $COMMIT == true ]]; then
  # Check if CHANGELOG.md has staged changes
  if git diff --cached --name-only | grep -q "^${CHANGELOG}$"; then
    # CHANGELOG.md is staged - check if it matches what git cliff would generate
    # We'll verify this after generating the expected content
    CHANGELOG_ALREADY_STAGED=true
  fi

  # Temporarily unstage other files so they don't get included in our commit
  OTHER_STAGED_FILES=$(git diff --cached --name-only | grep -v "^${CHANGELOG}$" || true)
  if [[ -n $OTHER_STAGED_FILES ]]; then
    echo "Temporarily unstaging other files..."
    while IFS= read -r file; do
      git restore --staged -- "$file"
    done <<< "$OTHER_STAGED_FILES"
  fi
fi

# Check if the last commit was an auto-update (avoid infinite loop)
LAST_COMMIT_MSG=$(git log -1 --pretty=%s 2> /dev/null || echo "")
LAST_COMMIT_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD 2> /dev/null || echo "")
if [[ $LAST_COMMIT_MSG == "$COMMIT_MSG" && $LAST_COMMIT_FILES == "$CHANGELOG" ]]; then
  echo "Skipping: Last commit was already a CHANGELOG auto-update."
  echo "No new commits to include."
  exit 0
fi

# Stash uncommitted changes to CHANGELOG.md if any
if ! git diff --quiet "$CHANGELOG" 2> /dev/null; then
  echo "Stashing uncommitted changes to ${CHANGELOG}..."
  git stash push -m "$STASH_MSG" -- "$CHANGELOG"
  STASHED=true
fi

TEMP_FILE=$(mktemp)
CLIFF_OUTPUT=$(mktemp)

# Generate unreleased changes with git cliff
git cliff --unreleased > "$CLIFF_OUTPUT"

# Extract the Unreleased section from git cliff output:
# - Start from "## [Unreleased]"
# - End before the next "## [" or "<!-- generated by git-cliff -->"
# - Exclude the git-cliff generated comment
awk '
  /^## \[Unreleased\]/ { in_unreleased = 1 }
  in_unreleased && /^<!-- generated by git-cliff -->/ { exit }
  in_unreleased && /^## \[/ && !/^## \[Unreleased\]/ { exit }
  in_unreleased { print }
' "$CLIFF_OUTPUT" > "$TEMP_FILE"

# Check if we got valid content
if [ ! -s "$TEMP_FILE" ]; then
  echo "Error: No Unreleased section found in git cliff output" >&2
  rm -f "$TEMP_FILE" "$CLIFF_OUTPUT"
  exit 1
fi

# Remove trailing blank lines from the extracted section
# but ensure it ends with exactly one newline
sed -i.bak -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$TEMP_FILE" 2> /dev/null || # spellchecker:disable-line
  sed -i '' -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$TEMP_FILE"                # spellchecker:disable-line
rm -f "${TEMP_FILE}.bak"

# Now replace the Unreleased section in CHANGELOG.md
# We need to:
# 1. Keep everything before "## [Unreleased]"
# 2. Insert the new Unreleased content
# 3. Keep everything from the next "## [" section onwards

awk -v new_content="$TEMP_FILE" '
  BEGIN { in_unreleased = 0; printed_new = 0 }

  # When we hit the Unreleased header, start skipping
  /^## \[Unreleased\]/ {
    in_unreleased = 1
    # Print the new content
    while ((getline line < new_content) > 0) {
      print line
    }
    close(new_content)
    printed_new = 1
    next
  }

  # When we hit the next version section, stop skipping
  in_unreleased && /^## \[/ && !/^## \[Unreleased\]/ {
    in_unreleased = 0
    # Ensure blank line before next section
    print ""
    print
    next
  }

  # Skip lines while in the old Unreleased section
  in_unreleased { next }

  # Print all other lines
  { print }
' "$CHANGELOG" > "${CHANGELOG}.new"

# If CHANGELOG.md is already staged, verify it matches what we'd generate
if [[ $CHANGELOG_ALREADY_STAGED == true ]]; then
  # Generate expected output from HEAD (not working tree which may be corrupted)
  HEAD_CHANGELOG=$(mktemp)
  EXPECTED_OUTPUT=$(mktemp)
  git show "HEAD:${CHANGELOG}" > "$HEAD_CHANGELOG"

  # Apply git cliff's Unreleased section to HEAD version
  awk -v new_content="$TEMP_FILE" '
    BEGIN { in_unreleased = 0; printed_new = 0 }
    /^## \[Unreleased\]/ {
      in_unreleased = 1
      while ((getline line < new_content) > 0) { print line }
      close(new_content)
      printed_new = 1
      next
    }
    in_unreleased && /^## \[/ && !/^## \[Unreleased\]/ {
      in_unreleased = 0
      print ""
      print
      next
    }
    in_unreleased { next }
    { print }
  ' "$HEAD_CHANGELOG" > "$EXPECTED_OUTPUT"

  # Get the staged version and compare
  STAGED_CONTENT=$(mktemp)
  git show ":${CHANGELOG}" > "$STAGED_CONTENT"

  if diff -q "$STAGED_CONTENT" "$EXPECTED_OUTPUT" > /dev/null 2>&1; then
    # Staged content matches - no need to update, just commit
    echo "Staged ${CHANGELOG} already matches git cliff output."
    rm -f "$STAGED_CONTENT" "$EXPECTED_OUTPUT" "$HEAD_CHANGELOG" "${CHANGELOG}.new" "$TEMP_FILE" "$CLIFF_OUTPUT"

    # Commit the already-staged changes
    git commit --no-verify -m "$COMMIT_MSG" -- "$CHANGELOG"
    echo "Committed ${CHANGELOG}."
    exit 0
  else
    # Staged content differs from what we'd generate
    echo "Error: ${CHANGELOG} has staged changes that differ from git cliff output." >&2
    echo "Unstage with: git restore --staged ${CHANGELOG}" >&2
    rm -f "$STAGED_CONTENT" "$EXPECTED_OUTPUT" "$HEAD_CHANGELOG" "${CHANGELOG}.new" "$TEMP_FILE" "$CLIFF_OUTPUT"
    exit 1
  fi
fi

# Replace the original file
mv "${CHANGELOG}.new" "$CHANGELOG"

# Cleanup
rm -f "$TEMP_FILE" "$CLIFF_OUTPUT"

# Check if git cliff produced any changes (comparing to HEAD)
if git diff --quiet HEAD -- "$CHANGELOG" 2> /dev/null; then
  # No changes from git cliff - already up-to-date
  if [[ $STASHED == true ]]; then
    # Restore user's original uncommitted changes
    git stash pop --quiet
    STASHED=false
    echo "Unreleased section is already up-to-date (your changes preserved)."
  else
    echo "Unreleased section is already up-to-date."
  fi
  # Re-stage other files before exiting
  restage_other_files
  trap - EXIT
  exit 0
fi

# Git cliff produced changes. Handle stashed user edits if any.
HAS_USER_EDITS=false
if [[ $STASHED == true ]]; then
  # Check if stashed content matches current working tree (user already had same changes)
  if diff -q <(git show "stash@{0}:${CHANGELOG}" 2> /dev/null) "$CHANGELOG" > /dev/null 2>&1; then
    # Stashed changes are identical to git cliff output - just drop the stash
    git stash drop --quiet
    STASHED=false
    echo "Your uncommitted changes match the git cliff output."
  else
    # User has different edits that need to be applied after committing
    HAS_USER_EDITS=true
  fi
fi

# Re-stage other files and disable cleanup trap - we're handling things manually from here
restage_other_files
trap - EXIT

echo "Successfully updated Unreleased section in $CHANGELOG"

# Stage and commit if requested
if [[ $COMMIT == true ]]; then
  git add "$CHANGELOG"
  git commit --no-verify -m "$COMMIT_MSG" -- "$CHANGELOG"
fi

# Now apply user's stashed edits on top (after the commit)
if [[ $HAS_USER_EDITS == true ]]; then
  if git stash apply --quiet 2> /dev/null; then
    # User's changes applied cleanly on top
    git stash drop --quiet
    STASHED=false
    # Check if stash actually added any changes beyond the update
    if git diff --quiet "$CHANGELOG" 2> /dev/null; then
      echo "Your uncommitted changes were already included in the update."
    else
      echo "Applied your uncommitted changes on top of the update."
    fi
  else
    # Conflict - undo the commit if we made one, restore original state
    echo "Error: Your uncommitted changes conflict with the git cliff update." >&2
    # First, abort the failed stash apply (clear merge state)
    git reset --merge
    if [[ $COMMIT == true ]]; then
      echo "Reverting the commit..." >&2
      git reset --soft HEAD~1
      git restore --staged "$CHANGELOG"
    fi
    echo "Restoring your original changes..." >&2
    # Reset file to HEAD (discard the git cliff update)
    git checkout HEAD -- "$CHANGELOG"
    # Restore user's original uncommitted changes
    git stash pop --quiet
    STASHED=false
    restage_other_files
    exit 1
  fi
fi
