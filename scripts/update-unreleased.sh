#!/usr/bin/env bash

set -euo pipefail

SCRIPT_NAME=$(basename "$0")
COMMIT=""
CHANGELOG="CHANGELOG.md"
CLIFF_ARGS=""

usage() {
  cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

Update the Unreleased section of CHANGELOG.md using git cliff.

This script runs 'git cliff --unreleased' to generate fresh changelog content,
then replaces the existing ## [Unreleased] section in CHANGELOG.md with the
newly generated content.

The '<!-- generated by git-cliff -->' comment is automatically excluded.

Options:
  -c, --commit        Stage and commit CHANGELOG.md after updating.
                      optionally accepts arguments to pass to 'git commit'
  -l, --changelog     path to changelog file (default: CHANGELOG.md)
  -C, --cliff-args    additional arguments to pass with 'git-cliff --unreleased'
  -h, --help          Show this help message and exit.

Examples:
  $SCRIPT_NAME                                            # Update CHANGELOG.md only
  $SCRIPT_NAME --commit                                   # Update, stage, and commit CHANGELOG.md (with defaults)
  $SCRIPT_NAME --commit "-m 'Custom message'"             # Commit with custom message
  $SCRIPT_NAME -l HISTORY.md                              # Update HISTORY.md instead
  $SCRIPT_NAME --cliff-args "--config custom-cliff.toml"  # Pass args to git-cliff
  $SCRIPT_NAME --help                                     # Show this help message

Requirements:
  - git cliff must be installed and available in PATH
  - Must be run from a git repository with a cliff.toml configuration
EOF
  exit "${1:-0}"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -c | --commit)
      if [[ $# -gt 1 ]] && [[ "${2:-}" != -* ]] && [[ -n "${2:-}" ]]; then
        # Next arg exists, doesn't start with -, and is not empty
        COMMIT="$2"
        shift 2
      else
        # No arg or arg starts with - or is empty string: use defaults
        COMMIT=""
        shift
      fi
      ;;
    -l | --changelog)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --changelog requires a file path" >&2
        usage 1
      fi
      CHANGELOG="$2"
      shift 2
      ;;
    -C | --cliff-args)
      if [[ -z "${2:-}" ]]; then
        echo "Error: --cliff-args requires arguments" >&2
        usage 1
      fi
      CLIFF_ARGS="$2"
      shift 2
      ;;
    -h | --help)
      usage 0
      ;;
    *)
      echo "Error: Unknown option: $1" >&2
      usage 1
      ;;
  esac
done

# Check we're in a git repository
if [ ! -d .git ]; then
  echo "Error: Must be run from the root of a git repository." >&2
  exit 1
fi

# Check git cliff is installed
if ! command -v git-cliff > /dev/null 2>&1 && ! command -v git cliff > /dev/null 2>&1; then
  echo "Error: git cliff is not installed or not available in PATH" >&2
  echo "Install it with: cargo install git-cliff" >&2
  exit 1
fi

# Check if changelog file exists
if [[ ! -f "$CHANGELOG" ]]; then
  echo "Error: $CHANGELOG does not exist" >&2
  exit 1
fi

COMMIT_MSG="docs(${CHANGELOG}): autoupdate Unreleased section"

# Check if the last commit was an auto-update (avoid infinite loop)
LAST_COMMIT_MSG=$(git log -1 --pretty=%s 2> /dev/null || echo "")
LAST_COMMIT_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD 2> /dev/null || echo "")
if [[ $LAST_COMMIT_MSG == "$COMMIT_MSG" && $LAST_COMMIT_FILES == "$CHANGELOG" ]]; then
  echo "Skipping: Last commit was already a CHANGELOG auto-update."
  echo "No new commits to include."
  exit 0
fi

# Convert string arguments to arrays for safe expansion
CLIFF_ARGS_ARRAY=()
COMMIT_ARGS_ARRAY=()
if [[ -n "$CLIFF_ARGS" ]]; then
  read -ra CLIFF_ARGS_ARRAY <<< "$CLIFF_ARGS"
fi
if [[ -n "$COMMIT" ]]; then
  read -ra COMMIT_ARGS_ARRAY <<< "$COMMIT"
fi

STASHED=false
STASH_REF=""
STASH_MSG="update-unreleased: auto-stash ${CHANGELOG}"

# Helper to re-stage files, skipping any that no longer exist
restage_other_files() {
  if [[ -z $OTHER_STAGED_FILES ]]; then
    return
  fi
  echo "Re-staging other files..."
  while IFS= read -r file; do
    if [[ -e $file ]]; then
      git add -- "$file"
    else
      echo "Warning: '$file' no longer exists (was it a new file?)" >&2
    fi
  done <<< "$OTHER_STAGED_FILES"
}

# Cleanup function to restore state on error
cleanup() {
  local exit_code=$?
  if [[ $STASHED == true ]] && [[ -n "$STASH_REF" ]]; then
    # Check if stash still exists before trying to pop
    if git stash list | grep -q "^${STASH_REF}"; then
      echo "Restoring stashed changes to ${CHANGELOG}..." >&2
      git stash pop --quiet "$STASH_REF" 2> /dev/null || git stash pop --quiet
    fi
  fi
  restage_other_files
  exit $exit_code
}
trap cleanup EXIT

# Track if CHANGELOG.md is already staged with correct content
CHANGELOG_ALREADY_STAGED=false
# Track other staged files we temporarily unstage
OTHER_STAGED_FILES=""

# If committing, check for conflicting staged changes
if [[ -n "$COMMIT" ]]; then
  # Check if CHANGELOG.md has staged changes
  if git diff --cached --name-only | grep -q "^${CHANGELOG}$"; then
    # CHANGELOG.md is staged - check if it matches what git cliff would generate
    # We'll verify this after generating the expected content
    CHANGELOG_ALREADY_STAGED=true
  fi

  # Temporarily unstage other files so they don't get included in our commit
  OTHER_STAGED_FILES=$(git diff --cached --name-only | grep -v "^${CHANGELOG}$" || true)
  if [[ -n $OTHER_STAGED_FILES ]]; then
    echo "Temporarily unstaging other files..."
    while IFS= read -r file; do
      git restore --staged -- "$file"
    done <<< "$OTHER_STAGED_FILES"
  fi
fi

# Stash uncommitted changes to CHANGELOG.md if any
if ! git diff --quiet "$CHANGELOG" 2> /dev/null; then
  echo "Stashing uncommitted changes to ${CHANGELOG}..."
  git stash push -m "$STASH_MSG" -- "$CHANGELOG"
  STASHED=true
  # Track the stash reference (most recent stash matching our message)
  STASH_REF=$(git stash list | grep -m1 -F "$STASH_MSG" | cut -d: -f1 || echo "")
fi

TEMP_FILE=$(mktemp)
CLIFF_OUTPUT=$(mktemp)

# Generate unreleased changes with git cliff
git cliff --unreleased "${CLIFF_ARGS_ARRAY[@]}" > "$CLIFF_OUTPUT"

# Extract the Unreleased section from git cliff output:
# - Start from "## [Unreleased]"
# - End before the next "## [" or "<!-- generated by git-cliff -->"
# - Exclude the git-cliff generated comment
awk '
  /^## \[Unreleased\]/ { in_unreleased = 1 }
  in_unreleased && /^<!-- generated by git-cliff -->/ { exit }
  in_unreleased && /^## \[/ && !/^## \[Unreleased\]/ { exit }
  in_unreleased { print }
' "$CLIFF_OUTPUT" > "$TEMP_FILE"

# Check if we got valid content
if [ ! -s "$TEMP_FILE" ]; then
  echo "Error: No Unreleased section found in git cliff output" >&2
  rm -f "$TEMP_FILE" "$CLIFF_OUTPUT"
  exit 1
fi

# Remove trailing blank lines from the extracted section
# but ensure it ends with exactly one newline
# Use a cross-platform approach: read file, remove trailing blank lines, ensure single newline
if command -v perl > /dev/null 2>&1; then
  # Perl is more reliable across platforms
  perl -i -pe 'chomp if eof' "$TEMP_FILE" 2> /dev/null || true
  # Ensure file ends with exactly one newline
  printf '\n' >> "$TEMP_FILE"
  # Remove any trailing blank lines (but keep at least one newline)
  perl -i -0777 -pe 's/\n+$/\n/' "$TEMP_FILE" 2> /dev/null || true
else
  # Fallback: try sed (GNU vs BSD)
  if sed --version > /dev/null 2>&1; then
    # GNU sed
    sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$TEMP_FILE" 2> /dev/null || true # spellchecker:disable-line
  else
    # BSD sed (macOS)
    sed -i '' -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$TEMP_FILE" 2> /dev/null || true # spellchecker:disable-line
  fi
  # Ensure file ends with exactly one newline
  if [[ -s "$TEMP_FILE" ]] && [[ $(tail -c1 "$TEMP_FILE" | wc -l) -eq 0 ]]; then
    printf '\n' >> "$TEMP_FILE"
  fi
fi

# Now replace the Unreleased section in CHANGELOG.md
# We need to:
# 1. Keep everything before "## [Unreleased]"
# 2. Insert the new Unreleased content
# 3. Keep everything from the next "## [" section onwards
# 4. If no Unreleased section exists, add it after header lines but before first version

awk -v new_content="$TEMP_FILE" '
  BEGIN { in_unreleased = 0; printed_new = 0; found_unreleased = 0 }

  # When we hit the Unreleased header, start skipping
  /^## \[Unreleased\]/ {
    found_unreleased = 1
    in_unreleased = 1
    # Print the new content
    while ((getline line < new_content) > 0) {
      print line
    }
    close(new_content)
    printed_new = 1
    next
  }

  # When we hit the next version section, stop skipping
  in_unreleased && /^## \[/ && !/^## \[Unreleased\]/ {
    in_unreleased = 0
    # Ensure blank line before next section
    print ""
    print
    next
  }

  # Skip lines while in the old Unreleased section
  in_unreleased { next }

  # If we hit the first version section and Unreleased has not been printed yet, insert it
  !printed_new && /^## \[/ && !/^## \[Unreleased\]/ {
    # Insert Unreleased section before this version
    while ((getline line < new_content) > 0)
      print line
    close(new_content)
    printed_new = 1
    # Ensure blank line before version section
    print ""
    print
    next
  }

  # Print all other lines
  { print }

  # If we reach the end and Unreleased has not been printed, add it
  END {
    if (!printed_new) {
      # Add blank line if file does not end with one
      if (NR > 0) print ""
      while ((getline line < new_content) > 0)
        print line
      close(new_content)
    }
  }
' "$CHANGELOG" > "${CHANGELOG}.new"

# If CHANGELOG.md is already staged, verify it matches what we'd generate
if [[ $CHANGELOG_ALREADY_STAGED == true ]]; then
  # Generate expected output from HEAD (not working tree which may be corrupted)
  HEAD_CHANGELOG=$(mktemp)
  EXPECTED_OUTPUT=$(mktemp)
  git show "HEAD:${CHANGELOG}" > "$HEAD_CHANGELOG"

  # Apply git cliff's Unreleased section to HEAD version
  awk -v new_content="$TEMP_FILE" '
    BEGIN { in_unreleased = 0; printed_new = 0 }
    /^## \[Unreleased\]/ {
      in_unreleased = 1
      while ((getline line < new_content) > 0)
        print line
      close(new_content)
      printed_new = 1
      next
    }
    in_unreleased && /^## \[/ && !/^## \[Unreleased\]/ {
      in_unreleased = 0
      print ""
      print
      next
    }
    in_unreleased { next }
    !printed_new && /^## \[/ && !/^## \[Unreleased\]/ {
      while ((getline line < new_content) > 0)
        print line
      close(new_content)
      printed_new = 1
      print ""
      print
      next
    }
    { print }
    END {
      if (!printed_new) {
        if (NR > 0) print ""
        while ((getline line < new_content) > 0)
          print line
        close(new_content)
      }
    }
  ' "$HEAD_CHANGELOG" > "$EXPECTED_OUTPUT"

  # Get the staged version and compare
  STAGED_CONTENT=$(mktemp)
  git show ":${CHANGELOG}" > "$STAGED_CONTENT"

  if diff -q "$STAGED_CONTENT" "$EXPECTED_OUTPUT" > /dev/null 2>&1; then
    # Staged content matches - no need to update, just commit
    echo "Staged ${CHANGELOG} already matches git cliff output."
    rm -f "$STAGED_CONTENT" "$EXPECTED_OUTPUT" "$HEAD_CHANGELOG" "${CHANGELOG}.new" "$TEMP_FILE" "$CLIFF_OUTPUT"

    # Commit the already-staged changes
    # Check if user provided -m or --message in commit args
    HAS_MESSAGE=false
    for arg in "${COMMIT_ARGS_ARRAY[@]}"; do
      if [[ "$arg" == "-m" ]] || [[ "$arg" == "--message" ]]; then
        HAS_MESSAGE=true
        break
      fi
    done

    # Build commit command
    COMMIT_CMD=(git commit)
    if [[ $HAS_MESSAGE == false ]]; then
      COMMIT_CMD+=(-m "$COMMIT_MSG")
    fi
    COMMIT_CMD+=("${COMMIT_ARGS_ARRAY[@]}")
    COMMIT_CMD+=(-- "$CHANGELOG")
    "${COMMIT_CMD[@]}"
    echo "Committed ${CHANGELOG}."
    exit 0
  else
    # Staged content differs from what we'd generate
    echo "Error: ${CHANGELOG} has staged changes that differ from git cliff output." >&2
    echo "Unstage with: git restore --staged ${CHANGELOG}" >&2
    rm -f "$STAGED_CONTENT" "$EXPECTED_OUTPUT" "$HEAD_CHANGELOG" "${CHANGELOG}.new" "$TEMP_FILE" "$CLIFF_OUTPUT"
    exit 1
  fi
fi

# Replace the original file
mv "${CHANGELOG}.new" "$CHANGELOG"

# Cleanup
rm -f "$TEMP_FILE" "$CLIFF_OUTPUT"

# Check if git cliff produced any changes (comparing to HEAD)
if git diff --quiet HEAD -- "$CHANGELOG" 2> /dev/null; then
  # No changes from git cliff - already up-to-date
  if [[ $STASHED == true ]] && [[ -n "$STASH_REF" ]]; then
    # Restore user's original uncommitted changes
    git stash pop --quiet "$STASH_REF" 2> /dev/null || git stash pop --quiet
    STASHED=false
    STASH_REF=""
    echo "Unreleased section is already up-to-date (your changes preserved)."
  else
    echo "Unreleased section is already up-to-date."
  fi
  # Re-stage other files before exiting
  restage_other_files
  trap - EXIT
  exit 0
fi

# Git cliff produced changes. Handle stashed user edits if any.
HAS_USER_EDITS=false
if [[ $STASHED == true ]] && [[ -n "$STASH_REF" ]]; then
  # Check if stashed content matches current working tree (user already had same changes)
  # Use the tracked stash reference if available, otherwise fall back to stash@{0}
  STASH_TO_CHECK="${STASH_REF:-stash@{0}}"
  if diff -q <(git show "${STASH_TO_CHECK}:${CHANGELOG}" 2> /dev/null) "$CHANGELOG" > /dev/null 2>&1; then
    # Stashed changes are identical to git cliff output - just drop the stash
    git stash drop --quiet "$STASH_REF" 2> /dev/null || git stash drop --quiet
    STASHED=false
    STASH_REF=""
    echo "Your uncommitted changes match the git cliff output."
  else
    # User has different edits that need to be applied after committing
    HAS_USER_EDITS=true
  fi
fi

# Re-stage other files and disable cleanup trap - we're handling things manually from here
restage_other_files
trap - EXIT

echo "Successfully updated Unreleased section in $CHANGELOG"

# Stage and commit if requested
if [[ -n "$COMMIT" ]]; then
  git add "$CHANGELOG"

  # Check if user provided -m or --message in commit args
  HAS_MESSAGE=false
  for arg in "${COMMIT_ARGS_ARRAY[@]}"; do
    if [[ "$arg" == "-m" ]] || [[ "$arg" == "--message" ]]; then
      HAS_MESSAGE=true
      break
    fi
  done

  # Build commit command
  COMMIT_CMD=(git commit)
  if [[ $HAS_MESSAGE == false ]]; then
    COMMIT_CMD+=(-m "$COMMIT_MSG")
  fi
  COMMIT_CMD+=("${COMMIT_ARGS_ARRAY[@]}")
  COMMIT_CMD+=(-- "$CHANGELOG")
  "${COMMIT_CMD[@]}"
fi

# Now apply user's stashed edits on top (after the commit)
if [[ $HAS_USER_EDITS == true ]] && [[ -n "$STASH_REF" ]]; then
  # Use the tracked stash reference if available
  if git stash apply --quiet "$STASH_REF" 2> /dev/null; then
    # User's changes applied cleanly on top
    git stash drop --quiet "$STASH_REF" 2> /dev/null || git stash drop --quiet
    STASHED=false
    STASH_REF=""
    # Check if stash actually added any changes beyond the update
    if git diff --quiet "$CHANGELOG" 2> /dev/null; then
      echo "Your uncommitted changes were already included in the update."
    else
      echo "Applied your uncommitted changes on top of the update."
    fi
  else
    # Conflict - undo the commit if we made one, restore original state
    echo "Error: Your uncommitted changes conflict with the git cliff update." >&2
    # First, abort the failed stash apply (clear merge state)
    git reset --merge
    if [[ -n "$COMMIT" ]]; then
      echo "Reverting the commit..." >&2
      git reset --soft HEAD~1
      git restore --staged "$CHANGELOG"
    fi
    echo "Restoring your original changes..." >&2
    # Reset file to HEAD (discard the git cliff update)
    git checkout HEAD -- "$CHANGELOG"
    # Restore user's original uncommitted changes
    git stash pop --quiet "$STASH_REF" 2> /dev/null || git stash pop --quiet
    STASHED=false
    STASH_REF=""
    restage_other_files
    exit 1
  fi
fi
