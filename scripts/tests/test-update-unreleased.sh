#!/usr/bin/env bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "$0")"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
SUT="$REPO_ROOT/scripts/update-unreleased.sh"

TEST_ROOT="$(mktemp -d)"
cleanup() {
  rm -rf "$TEST_ROOT"
}
trap cleanup EXIT

usage() {
  cat << EOF
Usage: $SCRIPT_NAME [-h | --help]

Run tests for update-unreleased.sh.

Options:
  -h, --help  Show this help message and exit.
EOF
  exit "${1:-0}"
}

fail() {
  printf '[FAIL] %s\n' "$1" >&2
  exit 1
}

assert_file_exists() {
  local path="$1"
  [[ -f "$path" ]] || fail "Expected file to exist: $path"
}

assert_file_contains() {
  local path="$1"
  local needle="$2"
  grep -Fq -- "$needle" "$path" || fail "Expected '$needle' in $path"
}

assert_file_not_contains() {
  local path="$1"
  local needle="$2"
  if grep -Fq -- "$needle" "$path"; then
    fail "Did not expect '$needle' in $path"
  fi
}

assert_line_order() {
  local path="$1"
  local first="$2"
  local second="$3"
  local first_line second_line
  first_line="$(grep -nF -- "$first" "$path" | awk -F: 'NR==1 {print $1}')"
  second_line="$(grep -nF -- "$second" "$path" | awk -F: 'NR==1 {print $1}')"
  [[ -n "$first_line" ]] || fail "Could not find first marker: $first"
  [[ -n "$second_line" ]] || fail "Could not find second marker: $second"
  [[ "$first_line" -lt "$second_line" ]] || fail "Expected '$first' before '$second'"
}

setup_test_repo() {
  local name="$1"
  local repo="$TEST_ROOT/$name/repo"
  mkdir -p "$repo"
  (
    cd "$repo"
    git init -q
    git config user.name "Test User"
    git config user.email "test@example.com"
  )
  printf '%s\n' "$repo"
}

setup_mock_cliff() {
  local test_name="$1"
  local cliff_output="$TEST_ROOT/$test_name/mock-cliff-output.md"
  local bin_dir="$TEST_ROOT/$test_name/bin"
  mkdir -p "$bin_dir"

  cat > "$cliff_output" << 'EOF'
## [Unreleased]

### Features

- new feature from cliff

<!-- generated by git-cliff -->
EOF

  cat > "$bin_dir/git-cliff" << 'EOF'
#!/usr/bin/env bash
set -euo pipefail
if [[ "${1:-}" != "--unreleased" ]]; then
  echo "Expected --unreleased as first argument" >&2
  exit 1
fi
cat "${MOCK_CLIFF_OUTPUT:?}"
EOF
  chmod +x "$bin_dir/git-cliff"
  printf '%s\n' "$bin_dir"
}

setup_mock_cliff_logging() {
  local test_name="$1"
  local cliff_output="$TEST_ROOT/$test_name/mock-cliff-output.md"
  local bin_dir="$TEST_ROOT/$test_name/bin"
  mkdir -p "$bin_dir"

  cat > "$cliff_output" << 'EOF'
## [Unreleased]

### Features

- new feature from cliff

<!-- generated by git-cliff -->
EOF

  cat > "$bin_dir/git-cliff" << 'EOF'
#!/usr/bin/env bash
set -euo pipefail
printf '%s\n' "$@" > "${MOCK_CLIFF_OUTPUT:?}.args"
cat "${MOCK_CLIFF_OUTPUT:?}"
EOF
  chmod +x "$bin_dir/git-cliff"
  printf '%s\n' "$bin_dir"
}

write_default_changelog() {
  local path="$1"
  cat > "$path" << 'EOF'
# Changelog

All notable changes.

## [Unreleased]

### Features

- old feature placeholder

## [1.0.0] - 2024-01-01

### Features

- initial release
EOF
}

write_changelog_without_unreleased() {
  local path="$1"
  cat > "$path" << 'EOF'
# Changelog

All notable changes.

## [1.0.0] - 2024-01-01

### Features

- initial release
EOF
}

write_changelog_with_new_unreleased() {
  local path="$1"
  cat > "$path" << 'EOF'
# Changelog

All notable changes.

## [Unreleased]

### Features

- new feature from cliff

## [1.0.0] - 2024-01-01

### Features

- initial release
EOF
}

commit_file() {
  local repo="$1"
  local file="$2"
  local message="$3"
  (
    cd "$repo"
    git add "$file"
    git commit -q -m "$message"
  )
}

test_help_exits_zero() {
  "$SUT" --help > /dev/null
}

test_help_prints_usage() {
  local out
  out="$("$SUT" --help 2>&1)"
  [[ "$out" == *"Usage:"* ]] || fail "Expected help output to include 'Usage:'"
}

test_unknown_option_fails() {
  local out
  if out="$("$SUT" --invalid 2>&1)"; then
    fail "Expected unknown option to fail"
  fi
  [[ "$out" == *"Unknown option"* ]] || fail "Expected unknown option error message"
}

test_not_in_git_repo_fails() {
  local dir out
  dir="$TEST_ROOT/not-git"
  mkdir -p "$dir"
  if out="$(cd "$dir" && "$SUT" 2>&1)"; then
    fail "Expected non-git directory to fail"
  fi
  [[ "$out" == *"Must be run from the root of a git repository"* ]] || fail "Expected git repository error"
}

test_missing_changelog_fails() {
  local repo bin_dir out
  repo="$(setup_test_repo "missing-changelog")"
  bin_dir="$(setup_mock_cliff "missing-changelog")"
  if out="$(cd "$repo" && PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/missing-changelog/mock-cliff-output.md" "$SUT" 2>&1)"; then
    fail "Expected missing changelog to fail"
  fi
  [[ "$out" == *"CHANGELOG.md does not exist"* ]] || fail "Expected missing changelog error"
}

test_missing_cliff_fails() {
  local repo out tool_path
  repo="$(setup_test_repo "missing-cliff")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  tool_path="$TEST_ROOT/missing-cliff/bin"
  mkdir -p "$tool_path"
  ln -s "$(command -v bash)" "$tool_path/bash"
  ln -s "$(command -v basename)" "$tool_path/basename"
  if out="$(cd "$repo" && PATH="$tool_path" "$SUT" 2>&1)"; then
    fail "Expected missing git cliff to fail"
  fi
  [[ "$out" == *"git cliff is not installed"* ]] || fail "Expected missing git cliff message"
}

test_replaces_existing_unreleased_section() {
  local repo bin_dir
  repo="$(setup_test_repo "replace-unreleased")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  bin_dir="$(setup_mock_cliff "replace-unreleased")"
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/replace-unreleased/mock-cliff-output.md" "$SUT" > /dev/null
  )
  assert_file_contains "$repo/CHANGELOG.md" "- new feature from cliff"
  assert_file_not_contains "$repo/CHANGELOG.md" "- old feature placeholder"
}

test_preserves_content_before_unreleased() {
  local repo bin_dir
  repo="$(setup_test_repo "preserve-before")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  bin_dir="$(setup_mock_cliff "preserve-before")"
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/preserve-before/mock-cliff-output.md" "$SUT" > /dev/null
  )
  assert_file_contains "$repo/CHANGELOG.md" "# Changelog"
  assert_file_contains "$repo/CHANGELOG.md" "All notable changes."
}

test_preserves_version_sections_after_unreleased() {
  local repo bin_dir
  repo="$(setup_test_repo "preserve-after")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  bin_dir="$(setup_mock_cliff "preserve-after")"
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/preserve-after/mock-cliff-output.md" "$SUT" > /dev/null
  )
  assert_file_contains "$repo/CHANGELOG.md" "## [1.0.0] - 2024-01-01"
  assert_file_contains "$repo/CHANGELOG.md" "- initial release"
}

test_inserts_unreleased_when_none_exists() {
  local repo bin_dir
  repo="$(setup_test_repo "insert-unreleased")"
  write_changelog_without_unreleased "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog without unreleased"
  bin_dir="$(setup_mock_cliff "insert-unreleased")"
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/insert-unreleased/mock-cliff-output.md" "$SUT" > /dev/null
  )
  assert_file_contains "$repo/CHANGELOG.md" "## [Unreleased]"
  assert_line_order "$repo/CHANGELOG.md" "## [Unreleased]" "## [1.0.0] - 2024-01-01"
}

test_excludes_cliff_generated_comment() {
  local repo bin_dir
  repo="$(setup_test_repo "exclude-cliff-comment")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  bin_dir="$(setup_mock_cliff "exclude-cliff-comment")"
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/exclude-cliff-comment/mock-cliff-output.md" "$SUT" > /dev/null
  )
  assert_file_not_contains "$repo/CHANGELOG.md" "<!-- generated by git-cliff -->"
}

test_up_to_date_reports_no_change() {
  local repo bin_dir out
  repo="$(setup_test_repo "up-to-date")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  bin_dir="$(setup_mock_cliff "up-to-date")"

  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/up-to-date/mock-cliff-output.md" "$SUT" > /dev/null
    git add CHANGELOG.md
    git commit -q -m "test: update changelog fixture"
    out="$(PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/up-to-date/mock-cliff-output.md" "$SUT" 2>&1)"
    [[ "$out" == *"already up-to-date"* ]] || fail "Expected already up-to-date message"
    git diff --quiet HEAD -- CHANGELOG.md || fail "Expected no changelog changes"
  )
}

test_skips_when_last_commit_was_autoupdate() {
  local repo bin_dir out
  repo="$(setup_test_repo "skip-loop")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  (
    cd "$repo"
    echo "" >> CHANGELOG.md
    git add CHANGELOG.md
    git commit -q -m "docs(CHANGELOG.md): autoupdate Unreleased section"
  )
  bin_dir="$(setup_mock_cliff "skip-loop")"
  out="$(cd "$repo" && PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/skip-loop/mock-cliff-output.md" "$SUT" 2>&1)"
  [[ "$out" == *"Skipping: Last commit was already a CHANGELOG auto-update."* ]] || fail "Expected loop prevention skip message"
}

test_commit_flag_creates_commit() {
  local repo bin_dir before after files
  repo="$(setup_test_repo "commit-creates")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  bin_dir="$(setup_mock_cliff "commit-creates")"
  before="$(cd "$repo" && git rev-list --count HEAD)"
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/commit-creates/mock-cliff-output.md" "$SUT" --commit > /dev/null
  )
  after="$(cd "$repo" && git rev-list --count HEAD)"
  [[ "$after" -eq $((before + 1)) ]] || fail "Expected exactly one new commit"
  files="$(cd "$repo" && git diff-tree --no-commit-id --name-only -r HEAD)"
  [[ "$files" == "CHANGELOG.md" ]] || fail "Expected commit to include only CHANGELOG.md"
}

test_commit_default_message() {
  local repo bin_dir subject
  repo="$(setup_test_repo "commit-default-message")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  bin_dir="$(setup_mock_cliff "commit-default-message")"
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/commit-default-message/mock-cliff-output.md" "$SUT" --commit > /dev/null
  )
  subject="$(cd "$repo" && git log -1 --pretty=%s)"
  [[ "$subject" == "docs(CHANGELOG.md): autoupdate Unreleased section" ]] || fail "Expected default commit message"
}

test_commit_custom_message() {
  local repo bin_dir subject
  repo="$(setup_test_repo "commit-custom-message")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  bin_dir="$(setup_mock_cliff "commit-custom-message")"
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/commit-custom-message/mock-cliff-output.md" "$SUT" --commit -- -m "Custom msg" > /dev/null
  )
  subject="$(cd "$repo" && git log -1 --pretty=%s)"
  [[ "$subject" == "Custom msg" ]] || fail "Expected custom commit message"
}

test_custom_changelog_path() {
  local repo bin_dir
  repo="$(setup_test_repo "custom-changelog-path")"
  write_default_changelog "$repo/HISTORY.md"
  cat > "$repo/CHANGELOG.md" << 'EOF'
# Changelog

No update expected in this file.
EOF
  (
    cd "$repo"
    git add HISTORY.md CHANGELOG.md
    git commit -q -m "test: add changelog files"
  )
  bin_dir="$(setup_mock_cliff "custom-changelog-path")"
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/custom-changelog-path/mock-cliff-output.md" "$SUT" -l HISTORY.md > /dev/null
  )
  assert_file_contains "$repo/HISTORY.md" "- new feature from cliff"
  assert_file_contains "$repo/CHANGELOG.md" "No update expected in this file."
}

test_stashes_uncommitted_changelog_changes() {
  local repo bin_dir marker out
  marker="local uncommitted note"
  repo="$(setup_test_repo "stash-safety")"
  write_changelog_with_new_unreleased "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  printf '\n%s\n' "$marker" >> "$repo/CHANGELOG.md"
  bin_dir="$(setup_mock_cliff "stash-safety")"
  out="$(cd "$repo" && PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/stash-safety/mock-cliff-output.md" "$SUT" 2>&1)"
  [[ "$out" == *"your changes preserved"* ]] || fail "Expected stash preservation message"
  assert_file_contains "$repo/CHANGELOG.md" "- new feature from cliff"
  assert_file_contains "$repo/CHANGELOG.md" "$marker"
}

test_cliff_args_passed_through() {
  local repo bin_dir args_file
  repo="$(setup_test_repo "cliff-args")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  bin_dir="$(setup_mock_cliff_logging "cliff-args")"
  args_file="$TEST_ROOT/cliff-args/mock-cliff-output.md.args"
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/cliff-args/mock-cliff-output.md" \
      "$SUT" --cliff-args -- --tag v1.0.0 > /dev/null
  )
  assert_file_exists "$args_file"
  assert_file_contains "$args_file" "--unreleased"
  assert_file_contains "$args_file" "--tag"
  assert_file_contains "$args_file" "v1.0.0"
}

test_commit_staged_changelog_matching_cliff() {
  local repo bin_dir out subject
  repo="$(setup_test_repo "staged-match")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  bin_dir="$(setup_mock_cliff "staged-match")"
  # Run once to produce the expected output
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/staged-match/mock-cliff-output.md" "$SUT" > /dev/null
  )
  # Stage the result (this is exactly what cliff would produce from HEAD)
  (cd "$repo" && git add CHANGELOG.md)
  # Run again with --commit; staged content should match
  out="$(cd "$repo" && PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/staged-match/mock-cliff-output.md" "$SUT" --commit 2>&1)"
  [[ "$out" == *"already matches"* ]] || fail "Expected staged matches message"
  subject="$(cd "$repo" && git log -1 --pretty=%s)"
  [[ "$subject" == "docs(CHANGELOG.md): autoupdate Unreleased section" ]] || fail "Expected auto-commit message"
}

test_commit_staged_changelog_differing_fails() {
  local repo bin_dir out
  repo="$(setup_test_repo "staged-differ")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  bin_dir="$(setup_mock_cliff "staged-differ")"
  # Stage a manually modified changelog that differs from cliff output
  (
    cd "$repo"
    echo "manually staged content" >> CHANGELOG.md
    git add CHANGELOG.md
  )
  if out="$(cd "$repo" && PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/staged-differ/mock-cliff-output.md" "$SUT" --commit 2>&1)"; then
    fail "Expected staged changelog mismatch to fail"
  fi
  [[ "$out" == *"staged changes that differ"* ]] || fail "Expected staged changes differ error"
}

test_preserves_other_staged_files() {
  local repo bin_dir files staged
  repo="$(setup_test_repo "other-staged")"
  write_default_changelog "$repo/CHANGELOG.md"
  echo "initial" > "$repo/other.txt"
  (
    cd "$repo"
    git add CHANGELOG.md other.txt
    git commit -q -m "test: add files"
  )
  # Modify other.txt and stage it
  echo "modified" > "$repo/other.txt"
  (cd "$repo" && git add other.txt)
  bin_dir="$(setup_mock_cliff "other-staged")"
  (
    cd "$repo"
    PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/other-staged/mock-cliff-output.md" "$SUT" --commit > /dev/null
  )
  # The commit should only contain CHANGELOG.md
  files="$(cd "$repo" && git diff-tree --no-commit-id --name-only -r HEAD)"
  [[ "$files" == "CHANGELOG.md" ]] || fail "Expected commit to include only CHANGELOG.md"
  # other.txt should still be staged
  staged="$(cd "$repo" && git diff --cached --name-only)"
  [[ "$staged" == "other.txt" ]] || fail "Expected other.txt to still be staged"
}

test_conflict_with_uncommitted_changes_restores_state() {
  local repo bin_dir out
  repo="$(setup_test_repo "conflict-restore")"
  write_default_changelog "$repo/CHANGELOG.md"
  commit_file "$repo" "CHANGELOG.md" "test: add changelog fixture"
  # Overwrite with conflicting uncommitted changes to the Unreleased section
  cat > "$repo/CHANGELOG.md" << 'USEREOF'
# Changelog

All notable changes.

## [Unreleased]

### Features

- user modified feature
- another user edit

## [1.0.0] - 2024-01-01

### Features

- initial release
USEREOF
  bin_dir="$(setup_mock_cliff "conflict-restore")"
  if out="$(cd "$repo" && PATH="$bin_dir:$PATH" MOCK_CLIFF_OUTPUT="$TEST_ROOT/conflict-restore/mock-cliff-output.md" "$SUT" 2>&1)"; then
    fail "Expected conflict to cause failure"
  fi
  [[ "$out" == *"conflict"* ]] || fail "Expected conflict error message"
  # Verify user's uncommitted changes are restored
  assert_file_contains "$repo/CHANGELOG.md" "- user modified feature"
  assert_file_contains "$repo/CHANGELOG.md" "- another user edit"
}

for arg in "$@"; do
  case "$arg" in
    -h | --help)
      usage 0
      ;;
  esac
done

tests=(
  test_help_exits_zero
  test_help_prints_usage
  test_unknown_option_fails
  test_not_in_git_repo_fails
  test_missing_changelog_fails
  test_missing_cliff_fails
  test_replaces_existing_unreleased_section
  test_preserves_content_before_unreleased
  test_preserves_version_sections_after_unreleased
  test_inserts_unreleased_when_none_exists
  test_excludes_cliff_generated_comment
  test_up_to_date_reports_no_change
  test_skips_when_last_commit_was_autoupdate
  test_commit_flag_creates_commit
  test_commit_default_message
  test_commit_custom_message
  test_custom_changelog_path
  test_stashes_uncommitted_changelog_changes
  test_cliff_args_passed_through
  test_commit_staged_changelog_matching_cliff
  test_commit_staged_changelog_differing_fails
  test_preserves_other_staged_files
  test_conflict_with_uncommitted_changes_restores_state
)

for test_name in "${tests[@]}"; do
  if ! ("$test_name"); then
    printf '[FAIL] %s (test runner halted)\n' "$test_name" >&2
    exit 1
  fi
  printf '[PASS] %s\n' "$test_name"
done

printf '\nAll %d tests passed.\n' "${#tests[@]}"
