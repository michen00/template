# Claude Code Instructions for Python Projects

## 1. Repository Context

**This is a Python project derived from a template.**

- Uses modern Python tooling: `uv` (dependency management), `ruff` (linting/formatting), `mypy` (type checking), `pytest` (testing).
- The `Makefile` is the primary entry point for all development tasks.
- Follows Conventional Commits for version control.

## 2. Development Workflow

### Environment Setup

- **Dependency Manager:** `uv` automatically creates and manages a virtual environment (`.venv`) in the project root.
- **Execution:** Use `uv run <command>` to ensure commands execute within the virtual environment.
  - Example: `uv run python -m mymodule` (preferred over `python -m mymodule`)
- **Python Version:** >=3.11 (specified in `.python-version` and `pyproject.toml`)

### Git Configuration

- **Git LFS:** This project may use Git LFS for large files. Run `make develop` to configure it.
- **Blame Ignore:** A `.git-blame-ignore-revs` file excludes formatting commits from `git blame`. Configure via `git config blame.ignoreRevsFile .git-blame-ignore-revs` (handled by `make develop`).

### Common Commands (Makefile)

Use the `Makefile` as the primary interface for development tasks:

- **Install Dependencies:** `make develop` (installs dev dependencies, configures git hooks and git settings)
- **Run All Checks:** `make check` (runs format-all and test - this is what CI runs)
- **Run Tests:** `make test` (runs pytest with coverage)
- **Linting:** `make lint` (ruff check --fix)
- **Formatting:** `make format` (lint + ruff format) or `make format-all` (pre-commit + format-unsafe)
- **Clean Artifacts:** `make clean` (removes build artifacts, caches, etc.)
- **Git Hooks:** `make enable-git-hooks` / `make disable-git-hooks`
- **Publishing:** `make push-test` / `make push-prod` (if applicable)

### Testing Philosophy

- **Test-Driven Development (TDD):** Write tests before implementation to ensure requirements are met.
- **Test Categories by Purpose:**
  - **Type 1: Executable Documentation** - Tests that serve as usage examples. Should be DAMP (Descriptive And Meaningful Phrases) and well-commented. Place these "above the fold" in test files.
  - **Type 2: Coverage & Reliability** - Tests for edge cases, path coverage, and confidence. Can be more DRY but must remain readable.
- **Testing Paradigms by Scope:**
  - **Unit Tests:** Individual components in isolation.
  - **Integration Tests:** Interactions between components or external systems.
  - **Smoke Tests:** Quick checks for critical paths.
  - **Functional/E2E Tests:** Full workflows from a user's perspective.
  - **Regression Tests:** Specific tests for bugs to prevent recurrence.
- **What to Test:**
  - **Public Interfaces:** Test user-facing code thoroughly.
  - **Private Implementation:** Avoid testing private methods directly; test them through public interfaces.
- **Pytest Best Practices:**
  - **Fixtures:** Use `pytest` fixtures for setup/teardown (prefer `yield` fixtures). Use `conftest.py` for shared fixtures.
  - **Parametrization:** Use `@pytest.mark.parametrize` for data-driven tests.
  - **Markers:** Use markers (e.g., `@pytest.mark.slow`) to categorize tests.
  - **Style:** Prefer functional tests over class-based tests.

## 3. Project Structure

Typical layout for projects derived from this template:

```tree
project/
├── src/<project_name>/    # Source code
├── tests/                 # Test suite
├── .github/               # GitHub Actions workflows
├── pyproject.toml         # Project configuration
├── uv.lock                # Locked dependencies
├── Makefile               # Task runner
└── .venv/                 # Virtual environment (git-ignored)
```

### Configuration Files

- **Linting & Formatting:** `.ruff.toml`, `.pylintrc`, `.pre-commit-config.yaml`, `.codespellrc`, `.markdownlint.yml`, `.yamllint`, `.gitlint`, `.editorconfig`
- **Testing:** `pyproject.toml` (pytest config), `.coveragerc` (coverage config)
- **Editor:** `.editorconfig`, `.vscode/settings.json`, `.vscode/extensions.json`
- **Git:** `.gitignore`, `.gitattributes`, `.git-blame-ignore-revs`
- **Documentation:** `cliff.toml` (changelog), `.readthedocs.yaml`

## 4. Coding Guidelines

### Commit Messages

- **Format:** Conventional Commits - `<type>(<scope>): <subject>`
  - **Types:** `feat`, `fix`, `docs`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`
  - **Subject:** Imperative mood, <=50 characters
  - **Atomic:** One logical change per commit

### Code Style

- **Enforcement:** `ruff` (linting/formatting) and `mypy` (type checking)
- **Verification:** Run `make check` before committing to ensure all checks pass

### Backward Compatibility

- Maintain backward compatibility for public APIs, especially in minor and patch releases.
- Breaking changes must be documented and ideally deprecated first with warnings.

### Library Preferences

- **CLI:** `typer` with `rich-argparse` for command-line interfaces
- **Data Processing:** `polars` over `pandas` for data manipulation
- **Logging:** Structured logging via `structlog`
- **JSON:** `yapic-json` for high-performance JSON processing
- **Progress Indicators:** `tqdm` or `rich.progress` for long-running tasks

### CLI Guidelines

- Ensure all CLI tools have helpful `--help` messages.
- Use colors where helpful.
- Use heredocs (multi-line strings) for usage text and docstrings.

### Python Idioms & Best Practices

- **Concurrency:**
  - Use `concurrent.futures` for parallelism or `asyncio` for async I/O.
  - Concurrency should be optional (controlled by a flag). Always include a synchronous implementation.
- **Memory Optimization:** Use `__slots__` for classes where beneficial or to prevent dynamic attributes.
- **Return Values:** Use `NamedTuple` or `dataclass` for return values with >3 elements (avoid plain tuples).
- **Enums:** Use `StrEnum` (Python 3.11+) with `auto()` for string-based enumerations.
- **Path Manipulation:** Prefer `pathlib.Path` over `os.path` or string manipulation.
- **Membership Checks:** Use `set` for membership checks, but be mindful of casting overhead.
- **Loop Optimization:** Avoid repeated dot notation in tight loops. Cache methods/attributes outside loops.
- **Module Exports (`__all__`):** Define as a tuple (not list) near the top of the file, below the docstring.

### Type Hints

- Use modern type hints (Python 3.11+) for all function signatures: `list[str]`, `str | None`, etc.
- Annotate class attributes and significant variables.
- **Pydantic Types:** Use numeric convenience types (`NegativeInt`, `NonPositiveFloat`) to enforce constraints.
- **Annotated Constraints:** Use `typing.Annotated` with `pydantic.Field` for reusable constrained types.

  ```python
  from typing import Annotated
  from pydantic import Field, NonNegativeFloat, FiniteFloat

  # Examples of useful patterns:
  FinitePositiveFloat = Annotated[FiniteFloat, Field(gt=0.0)]
  Probability = Annotated[NonNegativeFloat, Field(le=1.0)]
  NonEmptyStr = Annotated[str, Field(min_length=1)]
  ```

### Documentation

- Follow **Google-style** docstrings.
- **Modules:** Include docstrings at the module level.
- **Classes:** All classes must have docstrings.
- **Constants & Enums:** Document constants and Enum members.
- **Functions & Methods:**
  - **`Args:` Section:** Use judiciously. Only include if it adds material value (complex logic, gotchas, non-obvious parameters).
  - **No Redundancy:** Don't repeat information already clear from the signature (types, self-explanatory names).
- **Syncing:** Keep `AGENTS.md`, `.github/copilot-instructions.md`, `.github/instructions/CI.instructions.md`, and `README.md` in sync with code changes.

## 5. Specific Task Instructions

### Adding a Dependency

1. Add it to `pyproject.toml` (under `dependencies` or `optional-dependencies`).
2. Run `uv lock` to update `uv.lock`.
3. Run `make develop` to sync the virtual environment.
4. Verify with `make check`.

### Modifying CI/CD

- Edit `.github/workflows/CI.yml` for workflow changes.
- Note: CI may have different behavior than local runs (e.g., stricter linting args).

### Running Tests

- **All Tests:** `make test`
- **Specific Test:** `uv run pytest tests/test_specific.py`
- **With Coverage:** `uv run pytest --cov=src --cov-report=html`
- **Markers:** `uv run pytest -m slow` (run only slow tests)

### Code Quality Checks

Before committing or pushing:

1. Run `make format-all` to format all code.
2. Run `make check` to run all CI checks locally.
3. Review `git status` and `git diff` to verify changes.

## 6. Working with Claude Code

### Preferred Workflow

1. **File Operations:** Use dedicated tools (Read, Edit, Write, Glob, Grep) instead of bash commands.
2. **Read Before Edit:** Always read files before modifying them to understand context.
3. **Use Make:** Prefer `make` commands over direct tool invocations (e.g., `make test` not `pytest`).
4. **Track Tasks:** Use TodoWrite for multi-step tasks to track progress.
5. **Verify:** Run `make check` before considering a task complete.

### Git Operations

When creating commits:

1. Run `git status` and `git diff` to understand changes.
2. Review `git log` to match the repository's commit message style.
3. Stage relevant files with `git add`.
4. Create a commit with a conventional commit message.
5. Include Claude Code attribution in commit messages:

   ```commit-message
   <type>(<scope>): <subject>

   <optional body>

   Generated with [Claude Code](https://claude.com/claude-code)

   Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
   ```

6. Do not push unless explicitly requested by the user.

### Key Reminders

- This project uses `uv` - always use `uv run` for command execution.
- The `Makefile` is the primary interface - use it instead of running tools directly.
- Follow Conventional Commits for all commit messages.
- Run `make check` to verify changes before committing.
- Keep documentation in sync with code changes.
- Test public interfaces, not private implementation details.
- Prefer simple, focused solutions over over-engineering.
